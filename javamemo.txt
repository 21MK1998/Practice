
◎クラス = 設計図◎
	class クラス名{   <---これがクラスの基本設計
	}
◎メソッド(機能)とフィールド(データ)◎
	・メソッド
		[修飾子] 戻り値のデータ型　メソッド名(引数1,引数2・・){
		
		}
	・フィールド
		[修飾子] データ型 変数名;
◎mainメソッド(静的メソッド)◎
	・静的メソッドはメソッド名の前にstaticがついています。
◎文字列と数値◎
	プログラムの中で値として使用される文字は文字リテラル
	という呼び方もあります。
　リテラルとは・・・「〇〇の値」のこと。
	文字リテラルを記述するときは、「''(シングルクォーテーション)」
	で囲みます。
◎指数形式で浮動小数点を表記する◎
	例）3.2e2  ----> 3.2e2とは3.2 * 10の2乗
	例）2.4e-3 ----> 2.4e-3とは2.4 * 10の-3乗
◎数値リテラル(浮動小数点数)◎
	デフォルトではdouble型になっており、double型ほどの精度が必要ないばあい、
	最後に「F」または「ｆ」をつけて変数を宣言する。
	例）1.233F、0.83fなど
◎変数の宣言◎
	型名　変数名;
	※同じ型名の変数の宣言は続けて宣言できる 
		-> 例）int a,b,c;
◎整数と浮動小数点の演算◎
	整数同士の演算は結果は当然整数値だが、演算式に一つでも浮動小数点が含まれている場合は
	演算の結果は浮動小数点になる！！
◎単項マイナス演算子◎
	・単項マイナス演算子は演算子の右側の変数の正と負を反転させます。
	exa) int n1,n2,n3;

		n1 = 10;
		n2 = -n1;	//n2 = -10
		n3 = -8;
◎条件演算子(三項演算子)◎
	条件式 ? 式1 : 式2
		・処理の流れ
		   条件式がtrueの場合 -->式1を実行
		   条件式がfalseの場合-->式2を実行
◎拡張for文(for-each文)◎
	書式	for(データ型 変数名: コレクション){
			実行する文；
			実行する文;
			・・・
		}
	※実行する文が一行の時は{}は省略可
◎ラベル付きbreak文・continue文◎
	◦普通のbreak文・continue文との違い
		通常は一番内側のブロック(  )を抜けますが、ラベル付きにすることで
		任意の場所のブロックに抜けることができます
	書式	ラベル:  {
		　・・・
		　 break ラベル;
		  ・・・
		}
◎配列の長さを取得◎
	・配列
		書式 配列変数.length
	※多次元配列の場合、要素ごとに長さを取得できる。
	配列変数[インデックス(数字or変数)].length
	・文字列
		書式 文字列変数.length()
		注)stringクラスのメソッドなので()を最後に記述します。 
	
◎多次元配列の初期化◎
	書式 型名　配列変数名[][] = {
		{値0_0,値0_1,・・・},
		{値1_0,値1_1,・・・},
		};	
◎オブジェクトの作成◎
	〇Stringクラスのオブジェクト
		String str = "文字列";
	※変数strには値そのものが格納されているのではなく、配列の場所
		が格納されている。				
◎文字列比較◎
	×例) i == i2;
	〇例) i.equals(i2);
◎指定の位置の文字を所得◎
	書式 文字列.charAt(インデックス)
◎メソッドの詳しい解説◎
	・メソッドはクラスの中に記述します。
	・クラスの中でどの位置にmainメソッドが記述されていても、
	　最初に呼び出されるメソッドはmainメソッドで、ほかのメソッドは
	　明示的に呼び出されない限り実行されることはありません。
◎メソッドのオーバーロード◎
	・・・データ型や引数の数が一致していなければ、異なるメソッドに
		同じメソッド名を記述できます(条件あり)。
	・オーバーロードができる場合
		〇引数の数が異なっているとき。
		〇引数の種類が異なっているとき。
		〇引数の数は同じでも順番が異なっているとき。
	・できない場合
		✖引数の変数名だけが異なっている場合
		✖戻り値だけが異なっている場合

	※オーバーロードが使われている場面(System.out.println(引数);)
		・引数に整数を入れても、文字列を入力しても同じように画面に
		出力されるのは個のオーバーロードの仕組みを利用しているからである。
◎可変引数◎
	引数として指定するオブジェクトの中に複数同じデータ型の引数がある場合、まとめて
	1つの変数として呼び出したメソッドに引数を渡すことができる。(メソッド側では引数の箇所に記述した
	変数名を持つ配列を受け取ったように処理が行われます)

	書式	修飾子 戻り値の型 メソッド名(データ型...変数名)

	※引数に可変引数と非可変引数両方を引数として指定する場合は先に非可変引数を記述する。
	書式	修飾子 戻り値の型 メソッド名(データ型　変数名、データ型...変数名)
◎キャスト演算子◎
	書式　(データ型)式
※サイズが小さい型から大きい型への代入を行う際は明示的にキャスト演算子を用いる必要はありません(自動的に変換されるため)
◎ラッパークラスとオートボクシング◎
	ラッパークラスとは・・・基本データ型(int型など)の値を持ち、さまざまなメソッドを用いてデータ型に対して操作を行う
				ことができるクラスのこと。
	基本書式: データ型 変数x;
		  ラッパークラス(Integerなど) ラッパー変数 = new ラッパークラス(変数x);

					||

	オートボクシングの書式: データ型　変数x;
				ラッパークラス(Integerなど)　ラッパー変数 = 変数x;
	※変数xの部分には変数名または数字や文字列をそのまま記述できる


・valueメソッド {ラッパークラスのオブジェクトの値の取得}
	書式: 	データ型 変数x;
		ラッパークラス(Integerなど) ラッパー変数 = new ラッパークラス(変数x);
		データ型 変数y = ラッパー変数名.データ型value();	//ほかの取得方法 --> System.out.print(ラッパー変数.データ型value()または(変数ｙ));
					
					||

	オートボクシングでの書式: データ型　変数x;
				  ラッパークラス(Integerなど)　ラッパー変数 = 変数x;
				  データ型　変数ｙ = ラッパー変数;

・toStringメソッドとvalueOfメソッドと'+'演算子 {ラッパークラスのオブジェクトの値を変換(数値から文字列)}
	toString書式:	データ型　変数x;
			ラッパークラス(Integerなど)　ラッパー変数 = 変数x;
			String 変数名 = ラッパー変数.toString();
	valueOf書式:	データ型　変数x;
			ラッパークラス(Integerなど)　ラッパー変数 = 変数x;
			String 変数名 = String.valueOf(変数x);
		※valueOfの引数にはラッパークラスのオブジェクトではなく、基本データ型の値を引数に指定する
	'+'演算子書式;	データ型　変数x;
			String str = "文字列" + 数値;	// '+'演算子は文字列と数値を連結させるときは数値を文字列に変換して連結する

・parseデータ型(Intなど)メソッドとvalueOfメソッドとコンストラクタ {ラッパークラスのオブジェクトの値を変換(文字列から数値)}
	parseデータ型(Int型)書式:	String 変数名x = "";
					データ型 変数名y = データ型.parseデータ型(変数名x); //parseの後のデータ型の先頭は大文字(Intなど)
	valueOf書式:	String 変数x = "";
			ラッパークラス(Integerなど) 変数y = ラッパークラス(Integerなど).valueOf(変数x);
		※valueOfの引数にはラッパークラスのオブジェクトではなく、基本データ型の値を引数に指定する
	コンストラクタ書式;	String 変数x = "";
				ラッパークラス(Integerなど) 変数y = new ラッパークラス(変数x);	//Integerなどのラッパークラスのオブジェクトを作成するときに
												　引数に文字列を指定すると引数の文字列を表す数値を持つオブ
												　ジェクトを作成する
◎例外処理◎
try{

}catch{

}finally{

}				


 
幅 854
高さ 480

    

 